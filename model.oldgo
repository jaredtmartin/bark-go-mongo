package bark

import (
	"context"
	"fmt"
	"time"

	"go.mongodb.org/mongo-driver/v2/bson"
	"go.mongodb.org/mongo-driver/v2/mongo"
	"go.mongodb.org/mongo-driver/v2/mongo/options"
)

type Model interface {
	// Returns the unique identifier for the model
	GetId() string
	// Sets the unique identifier for the model
	SetId(id string)

	// Returns the collection for the model
	Collection(ctx context.Context) (*mongo.Collection, error)
	// Saves the object to the database
	Save(ctx context.Context) error
	// Deletes the object from the database
	Delete(ctx context.Context) error
}

// Base model to be embedded in all models
type DefaultModel struct {
	collection     *mongo.Collection
	CollectionName string    `json:"_" bson:"_"`
	ID             string    `json:"_id" bson:"_id,omitempty"`
	Id             string    `json:"Id" bson:"Id,omitempty"`
	CreatedOn      time.Time `json:"CreatedOn" bson:"CreatedOn,omitempty"`
	UpdatedOn      time.Time `json:"UpdatedOn" bson:"UpdatedOn,omitempty"`
	Version        int       `json:"Version" bson:"Version,omitempty"`
}

// Returns the unique identifier for the model
func (m *DefaultModel) GetId() string {
	return m.Id
}

// Sets the unique identifier for the model
func (m *DefaultModel) SetId(id string) {
	m.Id = id
	m.ID = id
}
func (m *DefaultModel) Collection(ctx context.Context) (*mongo.Collection, error) {
	// If you already have a collection cached, return it
	if m.collection != nil {
		return m.collection, nil
	}
	// If there's no collectionName, return an error
	if m.CollectionName == "" {
		return nil, fmt.Errorf("CollectionName not set")
	}
	// Get the database connection
	database, err := Db(ctx)
	if err != nil {
		return nil, fmt.Errorf("error getting collection %s for: %v", m.CollectionName, err)
	}
	// Get the collection
	m.collection = database.Collection(m.CollectionName)
	return m.collection, nil
}

func Save(model Model, ctx context.Context) error {
	// We don't ask for the collection, because we need the model and ctx here anyway,
	// so we can get the collection ourselves.
	collection, err := model.Collection(ctx)
	if err != nil {
		return fmt.Errorf("failed to get collection to save model to: %v", err)
	}
	if model.GetId() == "" {
		model.SetId(Uuid())
	}
	filter := bson.M{"Id": model.GetId()}
	update := bson.M{
		"$set": model,
		"$inc": bson.M{"Version": 1},
		"$setOnInsert": bson.M{
			"CreatedOn": Now(ctx),
		},
	}
	opts := options.UpdateOne().SetUpsert(true)
	res, err := collection.UpdateOne(ctx, filter, update, opts)
	fmt.Println("Saved: Matched:", res.MatchedCount, " Modified: ", res.ModifiedCount, " Upserted: ", res.UpsertedCount, " UpsertedID: ", res.UpsertedID)

	if err != nil {
		return err
	}
	return nil
}
func Delete(model Model, ctx context.Context) error {
	// We don't ask for the collection, because we need the model and ctx here anyway,
	// so we can get the collection ourselves.
	fmt.Printf("Deleting %v\n", model)
	collection, err := model.Collection(ctx)
	if err != nil {
		return fmt.Errorf("failed to get collection to save model to: %v", err)
	}
	filter := bson.M{"Id": model.GetId()}
	res, err := collection.DeleteOne(ctx, filter, nil)
	fmt.Println("Delete result: ", res)
	return err
}

// Collection level methods
// Returns all documents matching the filter
func (m *DefaultModel) Find(filter bson.M, results interface{}, opts *options.FindOptionsBuilder, ctx context.Context) error {
	cursor, err := m.collection.Find(ctx, filter, opts)
	if err != nil {
		return fmt.Errorf("error fetching documents: %v", err)
	}
	if err = cursor.All(ctx, results); err != nil {
		return fmt.Errorf("error decoding documents: %v", err)
	}
	return nil
}
func (m *DefaultModel) FindOne[t any](filter bson.M, ctx context.Context) (*DefaultModel, error) {
	collection, err := m.Collection(ctx)
	if err != nil {
		return fmt.Errorf("failed to get collection to save model to: %v", err)
	}
	obj := collection.FindOne(ctx, filter, nil)
	if err != nil {
		return fmt.Errorf("error fetching documents: %v", err)
	}
	return nil
}
func (m *DefaultModel) Load(ctx context.Context) error {
	collection, err := m.Collection(ctx)
	if err != nil {
		return fmt.Errorf("failed to get collection to save model to: %v", err)
	}
	filter := bson.M{"Id": m.Id}
	obj := collection.FindOne(ctx, filter, nil)
	if err != nil {
		return fmt.Errorf("error fetching documents: %v", err)
	}
	return nil
}

// Returns the total number of documents matching the filter
func (m *DefaultModel) Count(filter bson.M, ctx context.Context) (int64, error) {
	return m.collection.CountDocuments(ctx, filter)
}
func (m *DefaultModel) FindAndCount(filter bson.M, results interface{}, opts *options.FindOptionsBuilder, ctx context.Context) (int64, error) {
	err := Find(m.collection, filter, results, opts, ctx)
	if err != nil {
		return 0, err
	}
	count, err2 := Count(m.collection, filter, ctx)
	return count, err2
}
func (m *DefaultModel) All(results interface{}, opts *options.FindOptionsBuilder, ctx context.Context) error {
	filter := bson.M{}
	return Find(m.collection, filter, results, opts, ctx)
}
func (m *DefaultModel) Clear(ctx context.Context) error {
	collection, err := m.Collection(ctx)
	if err != nil {
		return fmt.Errorf("error getting collection to clear: %v", err)
	}
	if collection.Database().Name()[:4] != "test" {
		return ErrClearCanOnlyBeUsedOnDbsStartingWithTest
	}
	filter := bson.M{}
	_, err = collection.DeleteMany(ctx, filter)
	if err != nil {
		return fmt.Errorf("error clearing collection: %v", err)
	}
	return nil
}
